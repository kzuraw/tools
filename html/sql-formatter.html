<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SQL Formatter - sqlstyle.guide</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #f5f5f7;
        padding: 40px 20px;
        min-height: 100vh;
      }

      .container {
        max-width: 1000px;
        margin: 0 auto;
        background: white;
        border-radius: 12px;
        padding: 32px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      h1 {
        font-size: 28px;
        font-weight: 600;
        margin-bottom: 8px;
        color: #1d1d1f;
      }

      .subtitle {
        font-size: 14px;
        color: #86868b;
        margin-bottom: 24px;
      }

      .subtitle a {
        color: #0071e3;
        text-decoration: none;
      }

      .subtitle a:hover {
        text-decoration: underline;
      }

      textarea {
        width: 100%;
        font-family: "SF Mono", Monaco, monospace;
        font-size: 13px;
        padding: 16px;
        border: 1px solid #d2d2d7;
        border-radius: 8px;
        resize: vertical;
        margin-bottom: 16px;
        transition: border-color 0.2s;
        line-height: 1.5;
      }

      textarea:focus {
        outline: none;
        border-color: #0071e3;
      }

      #input {
        min-height: 250px;
      }

      #output {
        min-height: 250px;
        background: #f5f5f7;
      }

      .button-group {
        display: flex;
        gap: 12px;
        margin-top: 16px;
      }

      button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .primary {
        background: #0071e3;
        color: white;
      }

      .primary:hover {
        background: #0077ed;
      }

      .secondary {
        background: #e8e8ed;
        color: #1d1d1f;
      }

      .secondary:hover {
        background: #d2d2d7;
      }

      .success {
        background: #34c759;
        color: white;
      }

      label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
        color: #1d1d1f;
      }

      .options {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        padding: 16px;
        background: #f5f5f7;
        border-radius: 8px;
      }

      .option {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .option input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .option label {
        margin: 0;
        cursor: pointer;
        font-weight: 400;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>SQL Formatter</h1>
      <div class="subtitle">
        Formats SQL according to <a href="https://www.sqlstyle.guide/" target="_blank">sqlstyle.guide</a>
      </div>

      <label for="input">Paste SQL Query</label>
      <textarea
        id="input"
        placeholder="Paste your SQL query here..."
      ></textarea>

      <div class="options">
        <div class="option">
          <input type="checkbox" id="uppercase" checked />
          <label for="uppercase">Uppercase Keywords</label>
        </div>
        <div class="option">
          <input type="checkbox" id="indent" checked />
          <label for="indent">Auto Indent</label>
        </div>
        <div class="option">
          <input type="checkbox" id="newlines" checked />
          <label for="newlines">New Lines for Clauses</label>
        </div>
      </div>

      <label for="output">Formatted SQL</label>
      <textarea
        id="output"
        readonly
        placeholder="Formatted SQL will appear here"
      ></textarea>

      <div class="button-group">
        <button id="formatBtn" class="primary">Format SQL</button>
        <button id="copyBtn" class="secondary">Copy to Clipboard</button>
        <button id="clearBtn" class="secondary">Clear</button>
      </div>
    </div>

    <script>
      const input = document.getElementById("input");
      const output = document.getElementById("output");
      const formatBtn = document.getElementById("formatBtn");
      const copyBtn = document.getElementById("copyBtn");
      const clearBtn = document.getElementById("clearBtn");
      const uppercaseCheck = document.getElementById("uppercase");
      const indentCheck = document.getElementById("indent");
      const newlinesCheck = document.getElementById("newlines");

      // SQL Keywords that should be uppercased
      const keywords = [
        "SELECT", "FROM", "WHERE", "JOIN", "INNER", "LEFT", "RIGHT", "FULL", "OUTER",
        "ON", "AND", "OR", "NOT", "IN", "EXISTS", "BETWEEN", "LIKE", "IS", "NULL",
        "ORDER", "BY", "GROUP", "HAVING", "LIMIT", "OFFSET", "AS", "DISTINCT",
        "COUNT", "SUM", "AVG", "MAX", "MIN", "CASE", "WHEN", "THEN", "ELSE", "END",
        "INSERT", "INTO", "VALUES", "UPDATE", "SET", "DELETE", "CREATE", "TABLE",
        "ALTER", "DROP", "INDEX", "VIEW", "DATABASE", "SCHEMA", "UNION", "ALL",
        "INTERSECT", "EXCEPT", "WITH", "RECURSIVE", "OVER", "PARTITION", "ROWS",
        "RANGE", "UNBOUNDED", "PRECEDING", "FOLLOWING", "CURRENT", "ROW",
        "WINDOW", "CAST", "COALESCE", "NULLIF", "IFNULL", "SUBSTRING", "TRIM",
        "UPPER", "LOWER", "LENGTH", "REPLACE", "CONCAT", "DATE", "TIMESTAMP",
        "INTERVAL", "EXTRACT", "YEAR", "MONTH", "DAY", "HOUR", "MINUTE", "SECOND",
        "PRIMARY", "KEY", "FOREIGN", "REFERENCES", "UNIQUE", "CHECK", "DEFAULT",
        "CONSTRAINT", "CASCADE", "RESTRICT", "NO", "ACTION", "AUTOINCREMENT",
        "SERIAL", "BOOLEAN", "INTEGER", "INT", "BIGINT", "SMALLINT", "DECIMAL",
        "NUMERIC", "REAL", "FLOAT", "DOUBLE", "PRECISION", "VARCHAR", "CHAR",
        "TEXT", "BLOB", "CLOB", "JSONB", "JSON", "ARRAY", "BEGIN", "COMMIT",
        "ROLLBACK", "TRANSACTION", "SAVEPOINT", "RELEASE", "LOCK", "UNLOCK",
        "GRANT", "REVOKE", "PRIVILEGES", "TO", "RETURNING", "LATERAL", "CROSS",
        "NATURAL", "USING", "TRUE", "FALSE"
      ];

      // Major clause keywords that should start new lines
      const majorClauses = [
        "SELECT", "FROM", "WHERE", "JOIN", "INNER JOIN", "LEFT JOIN",
        "RIGHT JOIN", "FULL JOIN", "FULL OUTER JOIN", "LEFT OUTER JOIN",
        "RIGHT OUTER JOIN", "CROSS JOIN", "ORDER BY", "GROUP BY", "HAVING",
        "LIMIT", "OFFSET", "UNION", "UNION ALL", "INTERSECT", "EXCEPT",
        "INSERT INTO", "VALUES", "UPDATE", "SET", "DELETE FROM", "WITH"
      ];

      function formatSQL(sql) {
        if (!sql.trim()) return "";

        let formatted = sql;
        const useUppercase = uppercaseCheck.checked;
        const useIndent = indentCheck.checked;
        const useNewlines = newlinesCheck.checked;

        // Remove extra whitespace
        formatted = formatted.replace(/\s+/g, " ").trim();

        // Uppercase keywords if option is enabled
        if (useUppercase) {
          keywords.forEach(keyword => {
            const regex = new RegExp(`\\b${keyword}\\b`, "gi");
            formatted = formatted.replace(regex, keyword.toUpperCase());
          });
        }

        if (useNewlines) {
          // Add newlines before major clauses
          majorClauses.forEach(clause => {
            const regex = new RegExp(`\\s+(${clause.replace(/ /g, "\\s+")})\\b`, "gi");
            formatted = formatted.replace(regex, (match, p1) => {
              return "\n" + (useUppercase ? p1.toUpperCase() : p1);
            });
          });

          // Ensure SELECT is at the start
          formatted = formatted.replace(/^\s*\n/, "");

          // Add newlines after commas in SELECT clause
          formatted = formatted.replace(/,(\s*)(?=\S)/g, (match, space) => {
            // Check if we're in a SELECT clause (before FROM)
            return ",\n    ";
          });

          // Handle subqueries - add indentation
          let depth = 0;
          let result = "";
          let inString = false;
          let stringChar = "";

          for (let i = 0; i < formatted.length; i++) {
            const char = formatted[i];
            const prevChar = i > 0 ? formatted[i - 1] : "";

            // Track string literals
            if ((char === "'" || char === '"') && prevChar !== "\\") {
              if (!inString) {
                inString = true;
                stringChar = char;
              } else if (char === stringChar) {
                inString = false;
              }
            }

            if (!inString) {
              if (char === "(") {
                depth++;
                result += char;
                // Add newline and indent after opening paren if next char isn't whitespace
                if (i + 1 < formatted.length && formatted[i + 1].trim()) {
                  result += "\n" + "    ".repeat(depth);
                }
                continue;
              } else if (char === ")") {
                depth--;
                // Add newline and indent before closing paren
                if (prevChar.trim() && prevChar !== "(") {
                  result += "\n" + "    ".repeat(depth);
                }
                result += char;
                continue;
              }
            }

            result += char;
          }

          formatted = result;

          // Clean up excessive newlines
          formatted = formatted.replace(/\n{3,}/g, "\n\n");
          formatted = formatted.replace(/\n\s*\n\s*\n/g, "\n\n");
        }

        if (useIndent) {
          // Apply consistent indentation
          const lines = formatted.split("\n");
          let indentLevel = 0;
          const indentedLines = lines.map(line => {
            const trimmed = line.trim();
            if (!trimmed) return "";

            // Decrease indent for closing parens
            if (trimmed.startsWith(")")) {
              indentLevel = Math.max(0, indentLevel - 1);
            }

            const indented = "    ".repeat(indentLevel) + trimmed;

            // Increase indent for opening parens
            if (trimmed.endsWith("(") || trimmed.includes("(") && !trimmed.includes(")")) {
              indentLevel++;
            }

            // Adjust indent for major clauses at root level
            if (indentLevel === 0 && majorClauses.some(clause =>
              trimmed.toUpperCase().startsWith(clause.toUpperCase())
            )) {
              return trimmed;
            }

            return indented;
          });

          formatted = indentedLines.join("\n");
        }

        // Final cleanup
        formatted = formatted.replace(/\s+$/gm, ""); // Remove trailing spaces
        formatted = formatted.trim();

        return formatted;
      }

      formatBtn.addEventListener("click", () => {
        const sql = input.value;
        if (sql.trim()) {
          output.value = formatSQL(sql);
        }
      });

      // Auto-format on input with debounce
      let debounceTimer;
      input.addEventListener("input", () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          const sql = input.value;
          if (sql.trim()) {
            output.value = formatSQL(sql);
          } else {
            output.value = "";
          }
        }, 500);
      });

      // Re-format when options change
      [uppercaseCheck, indentCheck, newlinesCheck].forEach(checkbox => {
        checkbox.addEventListener("change", () => {
          if (input.value.trim()) {
            output.value = formatSQL(input.value);
          }
        });
      });

      copyBtn.addEventListener("click", async () => {
        if (output.value) {
          await navigator.clipboard.writeText(output.value);
          const originalText = copyBtn.textContent;
          copyBtn.textContent = "Copied!";
          copyBtn.classList.remove("secondary");
          copyBtn.classList.add("success");

          setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove("success");
            copyBtn.classList.add("secondary");
          }, 2000);
        }
      });

      clearBtn.addEventListener("click", () => {
        input.value = "";
        output.value = "";
      });
    </script>
  </body>
</html>
